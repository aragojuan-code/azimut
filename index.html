<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>Pieza 3D asimétrica – Definición + Visor</title>
  <style>
    html, body { height: 100%; margin: 0; background: #0b0f14; color: #e6eef7; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial; }
    .wrap { display: grid; grid-template-columns: 360px 1fr; min-height: 100vh; }
    aside { padding: 18px 16px; border-right: 1px solid rgba(255,255,255,.08); overflow: auto; }
    pre { white-space: pre-wrap; word-break: break-word; background: rgba(255,255,255,.04); padding: 12px; border-radius: 10px; }
    code { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: 12px; }
    #scene { position: relative; }
    canvas { display: block; width: 100%; height: 100%; }
    .hint { opacity: .8; font-size: 12px; }
    .badge { display:inline-block; padding:4px 8px; border-radius:999px; background:#1e293b; font-size:11px; margin-bottom:6px; }
  </style>
</head>
<body>
  <div class="wrap">
    <aside>
      <div class="badge">Definición matemática (unidad ≈ 1)</div>
      <pre><code id="math"></code></pre>
      <p class="hint">Arrastra con el ratón / dedo para orbitar. Rueda / pellizca para zoom. Pulsa <b>Espacio</b> para alternar <i>proyección de sombra</i>.</p>
    </aside>
    <div id="scene"></div>
  </div>

  <!-- Three.js + OrbitControls desde CDN -->
  <script src="https://unpkg.com/three@0.161.0/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.161.0/examples/js/controls/OrbitControls.js"></script>

  <script>
  // ==========================
  // 1) Definición matemática
  // ==========================
  // Pirámide oblicua con base triangular ESCALENA y ápice desplazado
  // Vértices (en unidades arbitrarias):
  const V = {
    B1: new THREE.Vector3( 0.00, 0.00, 0.00),
    B2: new THREE.Vector3( 1.30, 0.20, 0.00),
    B3: new THREE.Vector3(-0.40, 1.10, 0.00),
    A : new THREE.Vector3( 0.18,-0.12, 1.10), // ápice oblicuo
  };

  // Caras triangulares: cada cara define también una zona donde irá un cilindro
  // Índices y parámetros de salientes (uno por cara, todos distintos):
  const FACES = [
    // id, vertices,   cilindro: {altura h, radio r, tilt grados, offset baricéntrico (u,v,w)}
    { id:'F1', verts:['A','B1','B2'], cyl:{ h:0.25, r:0.10, tilt:  6, offset:[0.20,0.30,0.50] } },
    { id:'F2', verts:['A','B2','B3'], cyl:{ h:0.40, r:0.08, tilt: 11, offset:[0.15,0.70,0.15] } },
    { id:'F3', verts:['A','B3','B1'], cyl:{ h:0.60, r:0.12, tilt:  4, offset:[0.55,0.25,0.20] } },
    // Opcional: saliente en la base. Descomenta para añadir un cuarto cilindro.
    { id:'BASE', verts:['B1','B2','B3'], cyl:{ h:0.85, r:0.06, tilt: 15, offset:[0.30,0.15,0.55] } },
  ];

  // Utilidad: combinación baricéntrica p = u*P1 + v*P2 + w*P3, con u+v+w=1
  function baryPoint(u,v,w, P1,P2,P3){
    return new THREE.Vector3().addScaledVector(P1,u).addScaledVector(P2,v).addScaledVector(P3,w);
  }

  // ==========================
  // 2) Construcción de la malla
  // ==========================
  function buildPyramid(){
    const geom = new THREE.BufferGeometry();
    const verts = [];
    const pushTri = (p,q,r)=>{ verts.push(p.x,p.y,p.z, q.x,q.y,q.z, r.x,r.y,r.z); };
    // Caras laterales
    pushTri(V.A, V.B1, V.B2);
    pushTri(V.A, V.B2, V.B3);
    pushTri(V.A, V.B3, V.B1);
    // Base
    pushTri(V.B1, V.B2, V.B3);
    geom.setAttribute('position', new THREE.Float32BufferAttribute(verts,3));
    geom.computeVertexNormals();
    return geom;
  }

  // Crear cilindro sobre una cara (con tilt y offset únicos)
  function cylinderOnFace(face){
    const [a,b,c] = face.verts.map(k=>V[k]);
    const p = baryPoint(face.cyl.offset[0], face.cyl.offset[1], face.cyl.offset[2], a,b,c);
    // Normal de la cara
    const ab = new THREE.Vector3().subVectors(b,a);
    const ac = new THREE.Vector3().subVectors(c,a);
    const n  = new THREE.Vector3().crossVectors(ab,ac).normalize();

    // Crear eje con un tilt (inclinación) respecto a la normal
    const axis = n.clone();
    // Tilt alrededor de un vector en el plano de la cara (usa ab normalizado)
    const tiltAxis = ab.clone().normalize();
    const m = new THREE.Matrix4().makeRotationAxis(tiltAxis, THREE.MathUtils.degToRad(face.cyl.tilt));
    axis.applyMatrix4(m).normalize();

    // Geometría del cilindro (altura h, radio r):
    const h = face.cyl.h, r = face.cyl.r;
    const g = new THREE.CylinderGeometry(r, r, h, 24);
    const mat = new THREE.MeshStandardMaterial({ color: 0xd46f4d, roughness: 0.6, metalness: 0.1 });
    const cyl = new THREE.Mesh(g, mat);

    // Orientar cilindro para que su eje Y coincida con 'axis'
    // Por defecto, el eje del cilindro es +Y. Calculamos cuaternión de Y->axis
    const q = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,1,0), axis);
    cyl.quaternion.copy(q);

    // Colocar su centro en p + axis*(h/2) para que “salga” de la cara
    const center = p.clone().addScaledVector(axis, h/2);
    cyl.position.copy(center);

    return cyl;
  }

  // ==========================
  // 3) Escena Three.js
  // ==========================
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0b0f14);

  const renderer = new THREE.WebGLRenderer({ antialias:true });
  renderer.setSize(window.innerWidth - 360, window.innerHeight);
  renderer.shadowMap.enabled = true;
  document.getElementById('scene').appendChild(renderer.domElement);

  const camera = new THREE.PerspectiveCamera(45, (window.innerWidth-360)/window.innerHeight, 0.01, 100);
  camera.position.set(2.2, -2.0, 1.6);
  camera.lookAt(0.3,0.3,0.4);

  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;

  // Luz direccional (para sombras)
  const dir = new THREE.DirectionalLight(0xffffff, 1.0);
  dir.position.set(2.5, 1.5, 3.0);
  dir.castShadow = true;
  dir.shadow.mapSize.set(2048,2048);
  scene.add(dir);

  scene.add(new THREE.AmbientLight(0xffffff, 0.35));

  // Plano receptor (para ver la proyección/sombra)
  const plane = new THREE.Mesh(
    new THREE.PlaneGeometry(6,6),
    new THREE.ShadowMaterial({ opacity: 0.35 })
  );
  plane.rotation.x = -Math.PI/2;
  plane.position.z = -0.2; // ligeramente por debajo
  plane.receiveShadow = true;
  scene.add(plane);

  // Material del poliedro
  const polyMat = new THREE.MeshStandardMaterial({ color: 0xf0b27a, metalness: 0.05, roughness: 0.65 });

  // Pirámide
  const pyramid = new THREE.Mesh(buildPyramid(), polyMat);
  pyramid.castShadow = true;
  scene.add(pyramid);

  // Salientes
  const group = new THREE.Group();
  FACES.forEach(fc => group.add(cylinderOnFace(fc)));
  group.traverse(o=>{ if(o.isMesh){ o.castShadow = true; }});
  scene.add(group);

  // Texto matemático en el panel
  const mathEl = document.getElementById('math');
  const fmt = (v)=>`(${v.x.toFixed(2)}, ${v.y.toFixed(2)}, ${v.z.toFixed(2)})`;
  const lines = [];
  lines.push('Vértices:');
  lines.push(`  A  = ${fmt(V.A)}`);
  lines.push(`  B1 = ${fmt(V.B1)}`);
  lines.push(`  B2 = ${fmt(V.B2)}`);
  lines.push(`  B3 = ${fmt(V.B3)}`);
  lines.push('\nCaras (triángulos):');
  FACES.forEach(f=>{ lines.push(`  ${f.id}: ${f.verts.join('-')}`); });
  lines.push('\nSalientes por cara (cilindros):');
  FACES.forEach(f=>{
    const c = f.cyl; lines.push(`  ${f.id}: h=${c.h}, r=${c.r}, tilt=${c.tilt}°, offset=[${c.offset.map(n=>n.toFixed(2)).join(', ')}]`);
  });
  mathEl.textContent = lines.join('\n');

  // Alternar plano receptor/sombra con barra espaciadora
  let showShadow = true;
  window.addEventListener('keydown', (e)=>{
    if(e.code === 'Space'){
      showShadow = !showShadow;
      plane.visible = showShadow;
    }
  });

  // Resize
  window.addEventListener('resize', ()=>{
    const w = window.innerWidth - 360; const h = window.innerHeight;
    renderer.setSize(w,h); camera.aspect = w/h; camera.updateProjectionMatrix();
  });

  // Animación
  (function loop(){
    controls.update();
    renderer.render(scene, camera);
    requestAnimationFrame(loop);
  })();
  </script>
</body>
</html>
