<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>Pieza 3D asimétrica – Definición + Visor</title>
  <style>
    html, body { height: 100%; margin: 0; background: #0b0f14; color: #e6eef7; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial; }
    .wrap { display: grid; grid-template-columns: 360px 1fr; min-height: 100vh; }
    aside { padding: 18px 16px; border-right: 1px solid rgba(255,255,255,.08); overflow: auto; }
    pre { white-space: pre-wrap; word-break: break-word; background: rgba(255,255,255,.04); padding: 12px; border-radius: 10px; }
    code { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: 12px; }
    #scene { position: relative; width: 100%; height: 100vh; min-height: 400px; display: block; }
    canvas { display: block; width: 100%; height: 100%; }
    .hint { opacity: .8; font-size: 12px; }
    .badge { display:inline-block; padding:4px 8px; border-radius:999px; background:#1e293b; font-size:11px; margin-bottom:6px; }
  .err{position:absolute;left:12px;bottom:12px;background:#7f1d1d;color:#fee2e2;padding:8px 10px;border-radius:8px;font-size:12px;display:none;z-index:5}
</style>
</head>
<body>
  <div class="wrap">
    <aside>
      <div class="badge">Definición matemática (unidad ≈ 1)</div>
      <pre><code id="math"></code></pre>
      <p class="hint">Arrastra con el ratón / dedo para orbitar. Rueda / pellizca para zoom. Pulsa <b>Espacio</b> para alternar <i>proyección de sombra</i>.</p>
    </aside>
    <div id="scene"><div id="err" class="err"></div></div>
  </div>

  <!-- Three.js + OrbitControls desde CDN -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.161.0/examples/js/controls/OrbitControls.js"></script>

  <script>
// --- Build a minimal working viewer (safe version) ---
// If you still don't see it, the problem is not the 3D code.
(function(){
  const sceneEl = document.getElementById('scene');
  const errEl   = document.getElementById('err');
  function showErr(msg){ if(errEl){ errEl.style.display='block'; errEl.textContent=msg; } }
  if(!window.THREE){ showErr('No se cargó Three.js'); return; }

  // Scene & renderer
  const scene = new THREE.Scene();
  const renderer = new THREE.WebGLRenderer({antialias:true, alpha:false});
  renderer.setPixelRatio(Math.min(2, window.devicePixelRatio||1));
  sceneEl.appendChild(renderer.domElement);

  const camera = new THREE.PerspectiveCamera(45, 1, 0.01, 100);
  camera.position.set(2.6, 2.0, 2.2);

  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;

  // Helpers
  scene.add(new THREE.AxesHelper(1.2));
  const g = new THREE.GridHelper(8, 16, 0x334155, 0x1f2937); g.rotation.x=Math.PI/2; g.position.z=-0.2; scene.add(g);

  // --- Geometry: Asymmetric pyramid + cylinders ---
  const V = {
    B1: new THREE.Vector3(0.00, 0.00, 0.00),
    B2: new THREE.Vector3(1.30, 0.20, 0.00),
    B3: new THREE.Vector3(-0.40, 1.10, 0.00),
    A : new THREE.Vector3(0.18,-0.12, 1.10),
  };

  function pyramidGeom(){
    const geom = new THREE.BufferGeometry();
    const push=(a,b,c)=>verts.push(a.x,a.y,a.z,b.x,b.y,b.z,c.x,c.y,c.z);
    const verts=[];
    push(V.A,V.B1,V.B2);
    push(V.A,V.B2,V.B3);
    push(V.A,V.B3,V.B1);
    push(V.B1,V.B2,V.B3);
    geom.setAttribute('position', new THREE.Float32BufferAttribute(verts,3));
    geom.computeVertexNormals();
    return geom;
  }

  const matPoly = new THREE.MeshNormalMaterial({flatShading:false});
  const pyramid = new THREE.Mesh(pyramidGeom(), matPoly);
  scene.add(pyramid);

  // Cylinders on faces
  const faces = [
    { verts:['A','B1','B2'], h:0.25, r:0.10, tilt: 6,  off:[0.20,0.30,0.50]},
    { verts:['A','B2','B3'], h:0.40, r:0.08, tilt:11,  off:[0.15,0.70,0.15]},
    { verts:['A','B3','B1'], h:0.60, r:0.12, tilt: 4,  off:[0.55,0.25,0.20]},
    { verts:['B1','B2','B3'],h:0.85, r:0.06, tilt:15,  off:[0.30,0.15,0.55]},
  ];
  function bary([u,v,w], P,Q,R){ return new THREE.Vector3().addScaledVector(P,u).addScaledVector(Q,v).addScaledVector(R,w); }
  function cylOnFace(f){
    const a=V[f.verts[0]], b=V[f.verts[1]], c=V[f.verts[2]];
    const p=bary(f.off,a,b,c);
    const ab=new THREE.Vector3().subVectors(b,a);
    const ac=new THREE.Vector3().subVectors(c,a);
    const n=new THREE.Vector3().crossVectors(ab,ac).normalize();
    const axis=n.clone();
    const tiltAxis=ab.clone().normalize();
    axis.applyAxisAngle(tiltAxis, THREE.MathUtils.degToRad(f.tilt));
    const g=new THREE.CylinderGeometry(f.r,f.r,f.h,24);
    const m=new THREE.MeshNormalMaterial();
    const mesh=new THREE.Mesh(g,m);
    const q=new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,1,0), axis);
    mesh.quaternion.copy(q);
    mesh.position.copy(p.clone().addScaledVector(axis, f.h/2));
    return mesh;
  }
  const group=new THREE.Group(); faces.forEach(fc=>group.add(cylOnFace(fc))); scene.add(group);

  function resize(){
    const asideW = document.querySelector('aside')?.offsetWidth || 360;
    const w = Math.max(1, window.innerWidth - asideW);
    const h = Math.max(1, window.innerHeight);
    renderer.setSize(w,h,false);
    camera.aspect = w/h; camera.updateProjectionMatrix();
  }
  resize();
  window.addEventListener('resize', resize);
  window.addEventListener('orientationchange', ()=>setTimeout(resize,100));

  (function loop(){
    pyramid.rotation.z += 0.01; group.rotation.z += 0.01;
    controls.update(); renderer.render(scene,camera); requestAnimationFrame(loop);
  })();
})();
</script>
</body>
</html>
